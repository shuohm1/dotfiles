# .zsh_hooks

# hook functions
# 1. zshaddhistory: before the input command is added to histories
# 2. preexec:       before the input command is executed
# 3. -------------- the input command is executed
# 4. chpwd:         after the current working directory is changed
# 5. precmd:        before the prompt is shown (i.e. after the previous
#                   command exited)
# 6. periodic:      before the prompt is shown, but only if $PERIOD
#                   seconds have passed since the previous `periodic`
# *. zshexit:       before this zsh exits
autoload -Uz add-zsh-hook

# a helper function to retrieve a branch name
function retrieve_gitbranch() {
  git rev-parse --abbrev-ref HEAD 2> /dev/null | read retval

  # try to retrieve a commit hash instead of 'HEAD'
  if [ "${retval}" = "HEAD" ]; then
    git rev-parse --short HEAD 2> /dev/null | read retval
    if [ -z "${retval}" ]; then
      retval="HEAD"
    fi
  fi
}

# a helper function to compose a status list from git status
function compose_gitstatus_from_message() {
  local st="$1"

  # retrieve a status message
  git status 2> /dev/null | read -d '' retval
  compress_whitespaces "${retval}"
  # (L) turns the given word into lowercase (cf. man zshexpn)
  local msg="${(L)retval}"

  local re_cf='unmerged paths'
  local re_mg='still merging'
  local re_rb='rebase in progress'
  local re_ch='changes not staged for commit'
  local re_st='changes to be committed'
  local re_cl='working (directory|tree) clean'
  local re_ut='untracked files'

  if [[ "${msg}" =~ ${re_cf} ]]; then
    st="${st}${st:+,}conflict"
  fi
  if [[ "${msg}" =~ ${re_mg} ]]; then
    st="${st}${st:+,}merge"
  fi
  if [[ "${msg}" =~ ${re_rb} ]]; then
    st="${st}${st:+,}rebase"
  fi
  if [[ "${msg}" =~ ${re_ch} ]]; then
    st="${st}${st:+,}change"
  fi
  if [[ "${msg}" =~ ${re_st} ]]; then
    st="${st}${st:+,}stage"
  fi
  if [[ "${msg}" =~ ${re_cl} ]]; then
    st="${st}${st:+,}clean"
  fi
  if [[ "${msg}" =~ ${re_ut} ]]; then
    st="${st}${st:+,}untrack"
  fi

  if [ -n "${st}" ]; then
    retval="${st}"
  else
    retval="unknown"
  fi
}

# a helper function to compose a status list from git log
function compose_gitstatus_from_recentlogs() {
  local st="$1"

  # retrieve recent logs
  integer nlog="${NUM_RECENT_GITLOG:-80}"
  (( nlog = nlog < 0 ? 0 : nlog ))
  git log -n "${nlog}" --no-decorate --oneline | read -d '' retval
  # (f) splits words by newlines and make an array (cf. man zshexpn)
  typeset -a recent=("${(f)retval}")

  nlog=${#recent}
  integer i=0

  local re_up='^[df]e[[:xdigit:]]+'
  local re_sq='^[[:xdigit:]]+ (fixup|squash)[!?]'

  # NOTE: zsh uses 1-origin indices
  for (( i = 1; i < nlog; i++ )) do
    if [[ "${recent[$i]}" =~ ${re_up} ]]; then
      st="${st}${st:+,}unprefer"
      break
    fi
  done

  for (( i = 1; i < nlog; i++ )) do
    if [[ "${recent[$i]}" =~ ${re_sq} ]]; then
      st="${st}${st:+,}squash"
      break
    fi
  done

  retval="${st}"
}

# a hook for git status
function update_gitstatus() {
  GIT_STATUS=
  GIT_BRANCH=
  local retval=

  retrieve_gitbranch
  local br="${retval}"
  if [ -z "${br}" ]; then
    return
  fi

  retval=
  compose_gitstatus_from_message "${retval}"
  compose_gitstatus_from_recentlogs "${retval}"
  local st="${retval}"

  GIT_STATUS="${st}"
  GIT_BRANCH="${br}"
}

# a helper function for suffix of git status on a right prompt
function compose_suffix_rpgitstatus() {
  local x='!'
  local q='?'
  retval=

  if [[ "$1" = *unknown* ]]; then
    retval="$q"
    return
  fi

  if [ "${EXCLAMATIONMARK_GITRPROMPT:-0}" -ne 0 ]; then
    if [[ "$1" = *(squash|unprefer)* ]]; then
      retval="${retval}$x"
    fi
  fi

  if [ "${QUESTIONMARK_GITRPROMPT:-0}" -ne 0 ]; then
    if [[ "$1" = *untrack* ]]; then
      retval="${retval}$q"
    fi
  fi
}

# a helper function to compose git status on a right prompt
function compose_rpgitstatus() {
  local st="$1"
  local br="$2"
  local p="$3"
  local s="$4"

  # color numbers
  typeset -A n=([k]=0 [r]=1 [g]=2 [y]=3 [b]=4 [m]=5 [c]=6 [w]=7)
  if [[ "${TERM}" = *256color* ]]; then
    n[r]=166  # DarkOrange       #D75F00
    n[g]=76   # Chartreuse       #5FD700
    n[y]=185  # Khaki            #D7D75F
    n[b]=39   # DeepSkyBlue      #00AFFF
    n[m]=170  # Orchid           #D75FD7
    n[c]=80   # MediumTurquoise  #5FD7D7
  fi

  case "${st}" in
    conflict*)
      p="%F{${n[r]}}$p%f"
      s="%F{${n[r]}}$s%f"
      retval="$p%F{${n[w]}}%K{${n[r]}}${br}%k%f$s"
      ;;
    merge*)
      p="%F{${n[y]}}$p%f"
      s="%F{${n[y]}}$s%f"
      retval="$p%F{${n[k]}}%K{${n[y]}}${br}%k%f$s"
      ;;
    rebase*)
      p="%F{${n[c]}}$p%f"
      s="%F{${n[c]}}$s%f"
      retval="$p%F{${n[k]}}%K{${n[c]}}${br}%k%f$s"
      ;;
    change*)
      retval="%F{${n[r]}}$p${br}$s%f"
      ;;
    stage*)
      retval="%F{${n[y]}}$p${br}$s%f"
      ;;
    *unprefer*)
      retval="%F{${n[m]}}$p${br}$s%f"
      ;;
    *squash*)
      retval="%F{${n[b]}}$p${br}$s%f"
      ;;
    *untrack*)
      retval="%F{${n[c]}}$p${br}$s%f"
      ;;
    clean*)
      retval="%F{${n[g]}}$p${br}$s%f"
      ;;
    *)
      retval="%B%F{${n[k]}}$p${br}${s}%f%b"
      ;;
  esac
}

# git status on a right prompt
function update_rpgitstatus() {
  RPROMPT_GIT=
  if [ -z "${GIT_BRANCH}" ]; then
    return
  fi

  local retval=
  local st="${GIT_STATUS}"
  local br="${GIT_BRANCH}"

  # prefix: a broken vertical bar
  local prefix=$'\u00A6'
  # suffix
  compose_suffix_rpgitstatus "${st}"
  local suffix="${retval}"

  if [ "${UNPREFERABLEHASH_GITRPROMPT:-0}" -eq 0 ]; then
    st="${st//unprefer}"
  fi

  compose_rpgitstatus "${st}" "${br}" "${prefix}" "${suffix}"
  RPROMPT_GIT="${retval}"
}

# a hook for a right prompt
function update_rprompt() {
  if [ "${ENABLE_RPROMPT:-0}" -eq 0 ]; then
    RPROMPT=
    return
  fi

  local p=
  local t=
  if [ "${ENABLE_RPROMPT_GIT:-0}" -ne 0 ]; then
    update_rpgitstatus
    t="${RPROMPT_GIT}"
    p="$p$t${t:+ }"
  fi

  RPROMPT="${p% }"
}

# a helper function for renditions of hardstatus messages
function compose_hsrend() {
  retdict=()
  local esc=$'\x05'
  local if_="${esc}?"
  local fi_="${esc}?"
  local focus="${esc}F"
  retdict+=([rend]="${if_}${focus}${esc}{$1}${fi_}")
  retdict+=([revert]="${if_}${focus}${esc}{-}${fi_}")
}

# a helper function for a suffix of git status on a caption
function compose_suffix_capgitstatus() {
  local x='!'
  local q='?'
  retval=

  if [[ "$1" = *unknown* ]]; then
    retval="$q"
    return
  fi

  if [ "${EXCLAMATIONMARK_GITCAPTION:-0}" -ne 0 ]; then
    if [[ "$1" = *(squash|unprefer)* ]]; then
      retval="${retval}$x"
    fi
  fi

  if [ "${QUESTIONMARK_GITCAPTION:-0}" -ne 0 ]; then
    if [[ "$1" = *untrack* ]]; then
      retval="${retval}$q"
    fi
  fi
}

# a helper function for colors of git status on a caption
function compose_colors_capgitstatus() {
  local background="Y"
  local foreground="k"
  retval="${background}${foreground}"

  case "$1" in
    conflict*)
      retval="KR"
      ;;
    merge*)
      retval="KY"
      ;;
    rebase*)
      retval="KC"
      ;;
    change*)
      retval="yr"
      ;;
    stage*)
      retval="yk"
      ;;
    *unprefer*)
      retval="Mk"
      ;;
    *squash*untrack*|*untrack*squash*)
      retval="ck"
      ;;
    *untrack*)
      retval="Ck"
      ;;
    clean*squash*)
      retval="gk"
      ;;
    clean*)
      retval="Gk"
      ;;
    *)
      retval="Kw"
      ;;
  esac
}

# git status on a caption
function update_capgitstatus() {
  CAPTION_GIT=
  if [ -z "${GIT_BRANCH}" ]; then
    return
  fi

  local st="${GIT_STATUS}"
  local br="${GIT_BRANCH}"

  local retval=
  destroy_nonascii "${br}"
  br="${retval}"

  compose_suffix_capgitstatus "${st}"
  local suffix="${retval}"

  if [ "${UNPREFERABLEHASH_GITCAPTION:-0}" -eq 0 ]; then
    st="${st//unprefer}"
  fi

  compose_colors_capgitstatus "${st}"
  local colors="${retval}"

  typeset -A retdict=()
  compose_hsrend "+ ${colors}"
  local rend="${retdict[rend]}"
  local revert="${retdict[revert]}"
  CAPTION_GIT="${rend}(${br}${suffix})${revert}"
}

# hooks for a window title of screen
function update_prex_windowtitle() {
  if [ "${ENABLE_WINDOWTITLE:-0}" -eq 0 ]; then
    return
  elif [ -n "${WINDOWTITLE}" ]; then
    return
  fi

  # delete control characters, just in case
  local t="${1//[[:cntrl:]]}"
  # (z) splits words in a manner of shell parsing (cf. man zshexpn ->
  #     Parameter Expansion Flags)
  typeset -a args=("${(z)t}")
  # the entire command string for a sentinel
  t="${args[*]}"

  # find the 0th argument of the given command
  local s=
  local re='^([(){}]|[[:print:]]+[=])'
  for s in "${args[@]}"; do
    # - `s` does not start with parentheses nor braces
    # - `s` is not a setting of an environment variable
    if [[ ! ( "$s" =~ ${re} ) ]]; then
      t="$s"
      break
    fi
  done

  send_windowtitle "$t"
}

function update_prep_windowtitle() {
  if [ "${ENABLE_WINDOWTITLE:-0}" -ne 0 ]; then
    reset_windowtitle
  fi
}

# hooks for hardstatus messages of a window
function update_prex_hardstatus() {
  if [ -n "${HARDSTATUS}" ]; then
    return
  fi

  # update a hardstatus message for a caption
  local s=
  local t=
  if [ "${ENABLE_PREX_GITCAPTION:-0}" -ne 0 ]; then
    t="${CAPTION_GIT}"
    s="$s$t${t:+ }"
  fi
  send_hardstatus "${s% }"
}

function update_prep_hardstatus() {
  if [ -n "${HARDSTATUS}" ]; then
    send_hardstatus "${HARDSTATUS}"
    return
  fi

  # update a hardstatus message for a caption
  local s=
  local t=
  if [ "${ENABLE_PREP_GITCAPTION:-0}" -ne 0 ]; then
    update_capgitstatus
    t="${CAPTION_GIT}"
    s="$s$t${t:+ }"
  fi
  send_hardstatus "${s% }"
}

# register hooks
# - for git status
add-zsh-hook precmd update_gitstatus
# - for a right prompt
add-zsh-hook precmd update_rprompt
# - to clean up a hardstatus message
add-zsh-hook zshexit reset_hardstatus

# register hooks for screen
if [[ "${TERM}" = screen* ]]; then
  add-zsh-hook preexec update_prex_windowtitle
  add-zsh-hook preexec update_prex_hardstatus
  add-zsh-hook precmd  update_prep_windowtitle
  add-zsh-hook precmd  update_prep_hardstatus
fi
