# .zsh_hooks

# hook functions
# 1. zshaddhistory: before the input command is added to histories
# 2. preexec:       before the input command is executed
# 3. -------------- the input command is executed
# 4. chpwd:         after the current working directory is changed
# 5. precmd:        before the prompt is shown (i.e. after the previous
#                   command exited)
# 6. periodic:      before the prompt is shown, but only if $PERIOD
#                   seconds have passed since the previous `periodic`
# *. zshexit:       before this zsh exits
autoload -Uz add-zsh-hook

# a helper function to retrieve a branch name
function retrieve_gitbranch() {
  git rev-parse --abbrev-ref HEAD 2> /dev/null | read retval

  # try to retrieve a commit hash instead of 'HEAD'
  if [ "${retval}" = "HEAD" ]; then
    git rev-parse --short HEAD 2> /dev/null | read retval
    if [ -z "${retval}" ]; then
      retval="HEAD"
    fi
  fi
}

# a helper function to compose a status list from git status
function compose_gitstatus_from_message() {
  local st="$1"

  # retrieve a status message
  git status 2> /dev/null | read -d '' retval
  compress_whitespaces "${retval}"
  # (L) turns the given word into lowercase (cf. man zshexpn)
  local msg="${(L)retval}"

  local re_cf='unmerged paths'
  local re_mg='still merging'
  local re_rb='rebase in progress'
  local re_ch='changes not staged for commit'
  local re_st='changes to be committed'
  local re_cl='working (directory|tree) clean'
  local re_ut='untracked files'

  if [[ "${msg}" =~ ${re_cf} ]]; then
    st="${st}${st:+,}conflict"
  fi
  if [[ "${msg}" =~ ${re_mg} ]]; then
    st="${st}${st:+,}merge"
  fi
  if [[ "${msg}" =~ ${re_rb} ]]; then
    st="${st}${st:+,}rebase"
  fi
  if [[ "${msg}" =~ ${re_ch} ]]; then
    st="${st}${st:+,}change"
  fi
  if [[ "${msg}" =~ ${re_st} ]]; then
    st="${st}${st:+,}stage"
  fi
  if [[ "${msg}" =~ ${re_cl} ]]; then
    st="${st}${st:+,}clean"
  fi
  if [[ "${msg}" =~ ${re_ut} ]]; then
    st="${st}${st:+,}untrack"
  fi

  if [ -n "${st}" ]; then
    retval="${st}"
  else
    retval="unknown"
  fi
}

# a helper function to compose a status list from git log
function compose_gitstatus_from_recentlogs() {
  local st="$1"

  # retrieve recent logs
  integer nlog="${NUM_RECENT_GITLOG:-80}"
  (( nlog = nlog < 0 ? 0 : nlog ))
  git log -n "${nlog}" --no-decorate --oneline | read -d '' retval
  # (f) splits words by newlines and make an array (cf. man zshexpn)
  typeset -a recent=("${(f)retval}")

  nlog=${#recent}
  integer i=0

  local re_up='^[df]e[[:xdigit:]]+'
  local re_sq='^[[:xdigit:]]+ (fixup|squash)[!?]'

  # NOTE: zsh uses 1-origin indices
  for (( i = 1; i < nlog; i++ )) do
    if [[ "${recent[$i]}" =~ ${re_up} ]]; then
      st="${st}${st:+,}unprefer"
      break
    fi
  done

  for (( i = 1; i < nlog; i++ )) do
    if [[ "${recent[$i]}" =~ ${re_sq} ]]; then
      st="${st}${st:+,}squash"
      break
    fi
  done

  retval="${st}"
}

# a hook for git status
function update_gitstatus() {
  GIT_STATUS=
  GIT_BRANCH=
  local retval=

  retrieve_gitbranch
  local br="${retval}"
  if [ -z "${br}" ]; then
    return
  fi

  retval=
  compose_gitstatus_from_message "${retval}"
  compose_gitstatus_from_recentlogs "${retval}"
  local st="${retval}"

  GIT_STATUS="${st}"
  GIT_BRANCH="${br}"
}

# hooks for screen
function update_prex_windowtitle() {
  if [ "${ENABLE_WINDOWTITLE:-0}" -eq 0 ]; then
    return
  elif [ -n "${WINDOWTITLE}" ]; then
    return
  fi

  # delete control characters, just in case
  local t="${1//[[:cntrl:]]}"
  # (z) splits words in a manner of shell parsing (cf. man zshexpn ->
  #     Parameter Expansion Flags)
  typeset -a args=("${(z)t}")
  # the entire command string for a sentinel
  t="${args[*]}"

  # find the 0th argument of the given command
  local s=
  local re='^([(){}]|[[:print:]]+[=])'
  for s in "${args[@]}"; do
    # - `s` does not start with parentheses nor braces
    # - `s` is not a setting of an environment variable
    if [[ ! ( "$s" =~ ${re} ) ]]; then
      t="$s"
      break
    fi
  done

  send_windowtitle "$t"
}

function update_prep_windowtitle() {
  if [ "${ENABLE_WINDOWTITLE:-0}" -ne 0 ]; then
    reset_windowtitle
  fi
}

# register a hook for git status
add-zsh-hook precmd update_gitstatus

# register hooks for screen
if [[ "${TERM}" = screen* ]]; then
  add-zsh-hook preexec update_prex_windowtitle
  add-zsh-hook preexec reset_hardstatus
  add-zsh-hook precmd  update_prep_windowtitle
  add-zsh-hook precmd  reset_hardstatus
fi
